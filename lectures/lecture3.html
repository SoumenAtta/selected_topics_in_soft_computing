<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lecture 3 — Why Exact Methods Fail: Complexity, Scalability, and Motivation for Soft Computing – Selected Topics in Soft Computing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-6f49a141f7a0811b2f575e1b2f17f8d9.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-74bd2aec731b697f309a6167207bffde.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-6f49a141f7a0811b2f575e1b2f17f8d9.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../assets/site.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Selected Topics in Soft Computing</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../schedule.html"> 
<span class="menu-text">Schedule</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lectures" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lectures</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lectures">    
        <li>
    <a class="dropdown-item" href="../lectures/lecture1.html">
 <span class="dropdown-text">Lecture 1 — Introduction to Optimization</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture2.html">
 <span class="dropdown-text">Lecture 2 — Mathematical Programming with Python and Gurobi</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture3.html">
 <span class="dropdown-text">Lecture 3 — Why Exact Methods Fail: Complexity, Scalability, and Motivation for Soft Computing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture4.html">
 <span class="dropdown-text">Lecture 4 — Introduction to Heuristics and Metaheuristics</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#learning-objectives" id="toc-learning-objectives" class="nav-link active" data-scroll-target="#learning-objectives"><span class="header-section-number">1</span> Learning Objectives</a></li>
  <li><a href="#from-exact-optimization-to-soft-computing" id="toc-from-exact-optimization-to-soft-computing" class="nav-link" data-scroll-target="#from-exact-optimization-to-soft-computing"><span class="header-section-number">2</span> From Exact Optimization to Soft Computing</a>
  <ul class="collapse">
  <li><a href="#computational-complexity-an-intuitive-view" id="toc-computational-complexity-an-intuitive-view" class="nav-link" data-scroll-target="#computational-complexity-an-intuitive-view"><span class="header-section-number">2.1</span> Computational Complexity: An Intuitive View</a></li>
  <li><a href="#np-hardness-practical-intuition" id="toc-np-hardness-practical-intuition" class="nav-link" data-scroll-target="#np-hardness-practical-intuition"><span class="header-section-number">2.2</span> NP-Hardness: Practical Intuition</a></li>
  <li><a href="#combinatorial-explosion" id="toc-combinatorial-explosion" class="nav-link" data-scroll-target="#combinatorial-explosion"><span class="header-section-number">2.3</span> Combinatorial Explosion</a></li>
  </ul></li>
  <li><a href="#how-milp-solvers-work-high-level" id="toc-how-milp-solvers-work-high-level" class="nav-link" data-scroll-target="#how-milp-solvers-work-high-level"><span class="header-section-number">3</span> How MILP Solvers Work (High-Level)</a>
  <ul class="collapse">
  <li><a href="#why-milp-becomes-impractical" id="toc-why-milp-becomes-impractical" class="nav-link" data-scroll-target="#why-milp-becomes-impractical"><span class="header-section-number">3.1</span> Why MILP Becomes Impractical</a></li>
  <li><a href="#real-world-requirements-vs-exact-optimality" id="toc-real-world-requirements-vs-exact-optimality" class="nav-link" data-scroll-target="#real-world-requirements-vs-exact-optimality"><span class="header-section-number">3.2</span> Real-World Requirements vs Exact Optimality</a></li>
  </ul></li>
  <li><a href="#motivation-for-soft-computing" id="toc-motivation-for-soft-computing" class="nav-link" data-scroll-target="#motivation-for-soft-computing"><span class="header-section-number">4</span> Motivation for Soft Computing</a>
  <ul class="collapse">
  <li><a href="#heuristics-and-metaheuristics-as-alternatives" id="toc-heuristics-and-metaheuristics-as-alternatives" class="nav-link" data-scroll-target="#heuristics-and-metaheuristics-as-alternatives"><span class="header-section-number">4.1</span> Heuristics and Metaheuristics as Alternatives</a></li>
  <li><a href="#exact-methods-vs-soft-computing-a-comparison" id="toc-exact-methods-vs-soft-computing-a-comparison" class="nav-link" data-scroll-target="#exact-methods-vs-soft-computing-a-comparison"><span class="header-section-number">4.2</span> Exact Methods vs Soft Computing: A Comparison</a></li>
  <li><a href="#matheuristics-and-hybrid-approaches" id="toc-matheuristics-and-hybrid-approaches" class="nav-link" data-scroll-target="#matheuristics-and-hybrid-approaches"><span class="header-section-number">4.3</span> Matheuristics and Hybrid Approaches</a></li>
  <li><a href="#takeaways" id="toc-takeaways" class="nav-link" data-scroll-target="#takeaways"><span class="header-section-number">4.4</span> Takeaways</a></li>
  </ul></li>
  <li><a href="#mini-exercises" id="toc-mini-exercises" class="nav-link" data-scroll-target="#mini-exercises"><span class="header-section-number">5</span> Mini Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lecture 3 — Why Exact Methods Fail: Complexity, Scalability, and Motivation for Soft Computing</h1>
<p class="subtitle lead">NP-hardness intuition, combinatorial explosion, limits of MILP</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="learning-objectives" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="learning-objectives"><span class="header-section-number">1</span> Learning Objectives</h2>
<p>By the end of this lecture, students should be able to:</p>
<ul>
<li>understand the computational limitations of exact optimization methods<br>
</li>
<li>develop intuition about NP-hardness and combinatorial explosion<br>
</li>
<li>explain why MILP formulations become impractical for large-scale problems<br>
</li>
<li>distinguish worst-case complexity from practical performance<br>
</li>
<li>understand the role of heuristics and metaheuristics as scalable alternatives<br>
</li>
<li>motivate the need for soft computing approaches in real-world optimization</li>
</ul>
<hr>
</section>
<section id="from-exact-optimization-to-soft-computing" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="from-exact-optimization-to-soft-computing"><span class="header-section-number">2</span> From Exact Optimization to Soft Computing</h2>
<p>In the previous lectures, exact optimization methods such as LP, ILP, and MILP were introduced together with modern solvers like Gurobi. These tools represent the state of the art in <strong>exact decision-making</strong>, providing provably optimal solutions when computationally feasible. They form the backbone of many industrial decision support systems, especially in domains where solution quality, correctness, and optimality guarantees are critical.</p>
<p>However, despite continuous algorithmic and hardware advances, <strong>exact methods do not scale indefinitely</strong>. As problem size and structural complexity increase, many practically relevant optimization problems rapidly exceed the computational limits of exact solvers. This limitation is not merely an implementation issue, but a consequence of fundamental theoretical barriers.</p>
<p>Understanding <em>why</em> exact methods fail to scale is essential before introducing <strong>soft computing techniques</strong>, which deliberately trade optimality guarantees for scalability, flexibility, and robustness. This lecture therefore serves as the conceptual bridge between <strong>exact mathematical programming</strong> and <strong>heuristic and metaheuristic approaches</strong> that dominate large-scale optimization practice.</p>
<hr>
<section id="computational-complexity-an-intuitive-view" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="computational-complexity-an-intuitive-view"><span class="header-section-number">2.1</span> Computational Complexity: An Intuitive View</h3>
<p>Optimization problems differ not only in how difficult they are to model, but also in how difficult they are to <strong>solve computationally</strong>. This difficulty is captured by the notion of <strong>computational complexity</strong>, which describes how the amount of computation required grows as the problem size increases.</p>
<p>At a high level, algorithms fall into fundamentally different growth regimes.</p>
<p><strong>Polynomial-Time vs Exponential Growth</strong></p>
<ul>
<li><p><strong>Polynomial-time algorithms</strong> scale relatively well with problem size.</p>
<ul>
<li>Typical runtime grows like <span class="math inline">\(n^2\)</span>, <span class="math inline">\(n^3\)</span>, or another fixed power of the input size <span class="math inline">\(n\)</span>.</li>
<li>Linear programming, when solved using interior-point methods, belongs to this category from a theoretical perspective.</li>
</ul></li>
<li><p><strong>Exponential-time algorithms</strong> scale extremely poorly.</p>
<ul>
<li>Runtime grows like <span class="math inline">\(2^n\)</span>, <span class="math inline">\(n!\)</span>, or similarly fast-growing functions.</li>
<li>Even modest increases in problem size lead to dramatic increases in computational effort.</li>
</ul></li>
</ul>
<p>This distinction explains a key empirical observation: LPs with millions of variables can often be solved routinely, while ILPs or MILPs with only a few thousand binary variables may already be computationally intractable.</p>
<hr>
</section>
<section id="np-hardness-practical-intuition" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="np-hardness-practical-intuition"><span class="header-section-number">2.2</span> NP-Hardness: Practical Intuition</h3>
<p>Most integer and mixed-integer optimization problems are <strong>NP-hard</strong>. Informally, NP-hardness means that:</p>
<ul>
<li>no algorithm is known that can solve all instances of the problem efficiently (in polynomial time), and</li>
<li>the difficulty of solving the problem grows combinatorially with problem size in the worst case.</li>
</ul>
<p>From a practical standpoint, NP-hardness has several important implications.</p>
<p><strong>What NP-Hardness Means in Practice</strong></p>
<p>NP-hardness does <strong>not</strong> imply that every instance of an NP-hard problem is impossible to solve. Instead, it means:</p>
<ul>
<li>small or moderately sized instances may be solved optimally,</li>
<li>instances with special structure may be computationally easy, but</li>
<li>in the worst case, the solver must explore an exponential number of possibilities.</li>
</ul>
<p>As problem size increases, the solver may experience dramatic and unpredictable increases in runtime, even when only a small number of variables or constraints are added.</p>
<p>Classic NP-hard optimization problems include:</p>
<ul>
<li>the knapsack problem,</li>
<li>the traveling salesman problem,</li>
<li>set covering and set packing problems,</li>
<li>facility location problems, and</li>
<li>scheduling problems with setups or sequence-dependent constraints.</li>
</ul>
<p>Most real-world planning, design, and allocation problems contain one or more of these NP-hard problems as embedded substructures, which fundamentally limits the scalability of exact approaches.</p>
<hr>
</section>
<section id="combinatorial-explosion" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="combinatorial-explosion"><span class="header-section-number">2.3</span> Combinatorial Explosion</h3>
<p>The core source of difficulty in ILP and MILP is <strong>combinatorial explosion</strong>.</p>
<p><strong>Binary Variables and Search Space Size</strong></p>
<p>Binary decision variables encode discrete choices. If a model contains <span class="math inline">\(n\)</span> binary variables, then the total number of possible assignments is:</p>
<p><span class="math display">\[
2^n
\]</span></p>
<p>This growth is extremely rapid:</p>
<ul>
<li><span class="math inline">\(n = 20\)</span> → approximately <span class="math inline">\(10^6\)</span> combinations</li>
<li><span class="math inline">\(n = 40\)</span> → approximately <span class="math inline">\(10^{12}\)</span> combinations</li>
<li><span class="math inline">\(n = 100\)</span> → far beyond what can be enumerated in any realistic timeframe</li>
</ul>
<p>Even though modern solvers use advanced techniques such as bounding, cutting planes, and intelligent branching to avoid full enumeration, the underlying exponential growth cannot be eliminated. In the worst case, the solver must still consider an astronomically large search space.</p>
<p>This combinatorial explosion is the fundamental reason why exact enumeration-based methods eventually fail to scale, regardless of implementation quality or hardware improvements.</p>
<hr>
<p>Together, these observations explain the central motivation for <strong>soft computing</strong>: when exact optimality becomes computationally unattainable, alternative methods are required that can deliver high-quality solutions within acceptable time limits.</p>
<hr>
</section>
</section>
<section id="how-milp-solvers-work-high-level" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="how-milp-solvers-work-high-level"><span class="header-section-number">3</span> How MILP Solvers Work (High-Level)</h2>
<p>Modern MILP solvers are built around <strong>branch-and-bound</strong> and its enhanced variant, <strong>branch-and-cut</strong>. These frameworks systematically explore the space of integer solutions while using linear programming relaxations to guide and prune the search.</p>
<p>At a conceptual level, the solution process proceeds as follows:</p>
<ol type="1">
<li><p><strong>Solve the LP relaxation</strong> The integrality constraints are temporarily relaxed, allowing integer variables to take fractional values. This provides a bound on the optimal objective value.</p></li>
<li><p><strong>Check integrality</strong> If the LP solution satisfies all integrality requirements, it is an optimal solution to the MILP, and the algorithm terminates.</p></li>
<li><p><strong>Branch on a fractional variable</strong> If one or more integer variables take fractional values, the solver selects a variable and creates subproblems by fixing it to different integer values.</p></li>
<li><p><strong>Recursively explore subproblems</strong> Each subproblem defines a node in a search tree. The solver repeats the process of solving LP relaxations and branching.</p></li>
<li><p><strong>Prune using bounds</strong> If a subproblem cannot yield a better solution than the best one found so far, it is discarded without further exploration.</p></li>
</ol>
<p>Branch-and-cut strengthens this framework by dynamically adding <strong>cutting planes</strong> that eliminate fractional solutions without removing any integer-feasible solutions, thereby tightening LP relaxations.</p>
<p>Although highly effective in practice, this process can still generate <strong>millions or even billions of search tree nodes</strong> for large, weakly formulated, or poorly structured models.</p>
<hr>
<section id="why-milp-becomes-impractical" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="why-milp-becomes-impractical"><span class="header-section-number">3.1</span> Why MILP Becomes Impractical</h3>
<p>Despite decades of algorithmic improvements, MILP solvers face fundamental limitations that cannot be fully overcome.</p>
<p><strong>Model Size:</strong></p>
<ul>
<li>The number of variables and constraints can grow rapidly with problem size and modeling detail.</li>
<li>Large models consume significant memory and computational resources.</li>
<li>Presolve techniques may fail to substantially reduce very large or complex formulations.</li>
</ul>
<p><strong>Weak LP Relaxations:</strong></p>
<ul>
<li>Large <strong>integrality gaps</strong> lead to poor bounds and slow convergence.</li>
<li>Weak formulations reduce the effectiveness of pruning in the search tree.</li>
<li>Big-<span class="math inline">\(M\)</span> constraints often severely degrade relaxation quality and numerical stability.</li>
</ul>
<p><strong>Time Constraints:</strong></p>
<ul>
<li>Many real-world applications require decisions within seconds or minutes.</li>
<li>Exact solvers may require hours or days to prove optimality or even feasibility.</li>
<li>When time limits are imposed, solvers may return suboptimal solutions or fail to find any feasible solution at all.</li>
</ul>
<hr>
</section>
<section id="real-world-requirements-vs-exact-optimality" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="real-world-requirements-vs-exact-optimality"><span class="header-section-number">3.2</span> Real-World Requirements vs Exact Optimality</h3>
<p>In practical decision-making environments, the emphasis is often not on mathematical optimality, but on <strong>usable solutions within limited time</strong>. Decision-makers typically value:</p>
<ul>
<li>good-quality solutions obtained quickly,</li>
<li>robustness against data uncertainty and modeling imperfections,</li>
<li>scalability to large and complex instances, and</li>
<li>flexibility to incorporate domain-specific constraints and preferences.</li>
</ul>
<p>As a result, exact optimality is frequently <strong>less important than responsiveness and solution quality</strong>. This fundamental mismatch between theoretical optimality guarantees and practical requirements motivates the use of alternative solution paradigms, particularly heuristics, metaheuristics, and other soft computing approaches that emphasize scalability and adaptability over exactness.</p>
<hr>
</section>
</section>
<section id="motivation-for-soft-computing" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="motivation-for-soft-computing"><span class="header-section-number">4</span> Motivation for Soft Computing</h2>
<p><strong>Soft computing</strong> refers to a broad class of computational methods that deliberately relax the requirement of exact optimality in exchange for properties that are often more valuable in practice, namely:</p>
<ul>
<li><strong>scalability</strong> to large and complex problem instances,</li>
<li><strong>flexibility</strong> in modeling nonstandard, nonlinear, or problem-specific constraints,</li>
<li><strong>robustness</strong> with respect to noisy, incomplete, or uncertain data, and</li>
<li><strong>ease of implementation and adaptation</strong> to new problem variants.</li>
</ul>
<p>Rather than guaranteeing a mathematically optimal solution, soft computing methods aim to produce <strong>good or near-optimal solutions</strong> within acceptable computational time. This trade-off is often essential when dealing with large-scale, real-world decision problems where exact methods fail to deliver timely or usable solutions.</p>
<hr>
<section id="heuristics-and-metaheuristics-as-alternatives" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="heuristics-and-metaheuristics-as-alternatives"><span class="header-section-number">4.1</span> Heuristics and Metaheuristics as Alternatives</h3>
<p>Soft computing encompasses a wide range of heuristic and metaheuristic approaches designed to explore large solution spaces efficiently.</p>
<p>Common categories include:</p>
<ul>
<li><p><strong>Constructive heuristics</strong></p>
<ul>
<li>build a feasible solution step by step using fast, problem-specific rules,</li>
<li>often used to generate initial solutions.</li>
</ul></li>
<li><p><strong>Local search methods</strong></p>
<ul>
<li>start from an initial solution and iteratively improve it by exploring a neighborhood,</li>
<li>focus on intensification around promising regions of the search space.</li>
</ul></li>
<li><p><strong>Metaheuristics</strong></p>
<ul>
<li>general-purpose algorithmic frameworks that guide the search process,</li>
<li>balance exploration and exploitation to escape local optima,</li>
<li>examples include simulated annealing, tabu search, and genetic algorithms.</li>
</ul></li>
</ul>
<p>These methods share several important characteristics:</p>
<ul>
<li>they do not require convexity or linearity,</li>
<li>they naturally handle discrete, continuous, and mixed decision variables,</li>
<li>they scale well to very large problem instances, and</li>
<li>they can be easily hybridized with exact optimization techniques.</li>
</ul>
<hr>
</section>
<section id="exact-methods-vs-soft-computing-a-comparison" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="exact-methods-vs-soft-computing-a-comparison"><span class="header-section-number">4.2</span> Exact Methods vs Soft Computing: A Comparison</h3>
<p>The following table highlights the fundamental differences between exact optimization methods and soft computing approaches.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 43%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Exact Methods (MILP)</th>
<th>Soft Computing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Optimality guarantee</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="even">
<td>Scalability</td>
<td>Limited</td>
<td>High</td>
</tr>
<tr class="odd">
<td>Runtime predictability</td>
<td>Low</td>
<td>High</td>
</tr>
<tr class="even">
<td>Flexibility</td>
<td>Moderate</td>
<td>Very high</td>
</tr>
<tr class="odd">
<td>Modeling effort</td>
<td>High</td>
<td>Moderate</td>
</tr>
<tr class="even">
<td>Practical role</td>
<td>Baseline, validation, benchmarking</td>
<td>Primary solution method</td>
</tr>
</tbody>
</table>
<p>Rather than being competing paradigms, these approaches address different needs. Exact methods excel when problem size and structure permit, while soft computing dominates in large-scale, time-critical, or highly complex settings.</p>
<hr>
</section>
<section id="matheuristics-and-hybrid-approaches" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="matheuristics-and-hybrid-approaches"><span class="header-section-number">4.3</span> Matheuristics and Hybrid Approaches</h3>
<p>A powerful modern paradigm in optimization is <strong>hybrid optimization</strong>, often referred to as <strong>matheuristics</strong>. These approaches combine the strengths of exact mathematical programming and soft computing techniques.</p>
<p>Typical hybrid strategies include:</p>
<ul>
<li>using MILP models to capture problem structure and compute bounds,</li>
<li>generating high-quality initial solutions using heuristics,</li>
<li>improving incumbent solutions via local search or metaheuristics, and</li>
<li>applying exact solvers selectively on reduced or restricted subproblems.</li>
</ul>
<p>This combination leverages the rigor of exact optimization and the scalability of soft computing, and it represents the dominant solution paradigm in many contemporary research and industrial applications.</p>
<hr>
</section>
<section id="takeaways" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="takeaways"><span class="header-section-number">4.4</span> Takeaways</h3>
<ul>
<li>NP-hardness explains why many optimization problems do not scale<br>
</li>
<li>Binary decisions lead to exponential growth in solution space<br>
</li>
<li>MILP solvers are powerful but fundamentally limited<br>
</li>
<li>Exact optimality is often impractical for large problems<br>
</li>
<li>Soft computing provides scalable, flexible alternatives<br>
</li>
<li>Modern optimization increasingly relies on hybrid methods</li>
</ul>
<hr>
</section>
</section>
<section id="mini-exercises" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="mini-exercises"><span class="header-section-number">5</span> Mini Exercises</h2>
<ol type="1">
<li><p><strong>Combinatorial explosion with binary variables.</strong> A model has <span class="math inline">\(n = 50\)</span> binary decision variables.</p>
<ul>
<li>Compute the number of possible assignments, <span class="math inline">\(2^{50}\)</span>.</li>
<li>Express it approximately in scientific notation.</li>
<li>Explain why brute-force enumeration is infeasible even with very fast computers. <em>Hint:</em> Compare <span class="math inline">\(2^{50}\)</span> to <span class="math inline">\(10^{12}\)</span> and consider time per evaluation.</li>
</ul></li>
<li><p><strong>Near-optimal solutions in practice.</strong> Identify a real-life optimization problem where a near-optimal solution is acceptable, such as routing deliveries, shift scheduling, or production planning.</p>
<ul>
<li>Describe the decision variables and constraints at a high level.</li>
<li>Explain why computing an exact optimal solution is not necessary or not practical. <em>Hint:</em> Consider time pressure, uncertainty, changing data, or human preferences.</li>
</ul></li>
<li><p><strong>Heuristics as warm starts for MILP.</strong> MILP solvers benefit significantly from good feasible solutions early in the search.</p>
<ul>
<li>Propose one heuristic that can generate a feasible solution quickly for a MILP of your choice.</li>
<li>Explain how this heuristic solution could be passed as an initial solution (warm start) to an MILP solver.</li>
<li>Discuss why having a strong incumbent helps branch-and-bound. <em>Hint:</em> Better incumbents improve pruning by tightening the bound gap.</li>
</ul></li>
<li><p><strong>Sensitivity to one additional binary variable.</strong> Consider a problem where the decision space is controlled by binary variables.</p>
<ul>
<li>Explain how adding one more binary variable changes the theoretical search space size.</li>
<li>Provide an example scenario where adding one additional feature, option, or constraint introduces a new binary decision and increases difficulty substantially. <em>Hint:</em> Show how <span class="math inline">\(2^n\)</span> becomes <span class="math inline">\(2^{n+1}\)</span> and interpret this doubling effect.</li>
</ul></li>
</ol>
<hr>


</section>

</main> <!-- /main -->
<div class="ui-controls" role="group" aria-label="Display controls">
  <!-- Quarto already shows a light or dark toggle in the navbar when you set light and dark themes.
       Here we only add font size. -->
  <label for="fontSize" class="ui-label">A</label>
  <select id="fontSize" aria-label="Font size">
    <option value="16">A</option>
    <option value="18">A+</option>
    <option value="20">A++</option>
  </select>
</div>

<script>
(function () {
  const KEY = "q_font_size_px";
  const select = document.getElementById("fontSize");

  function apply(px) {
    document.documentElement.style.fontSize = px + "px";
  }

  // Load saved value or default to 16
  const saved = localStorage.getItem(KEY) || "16";
  select.value = saved;
  apply(saved);

  // Save on change
  select.addEventListener("change", () => {
    localStorage.setItem(KEY, select.value);
    apply(select.value);
  });
})();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Dr.&nbsp;Soumen Atta, Ph.D.&nbsp;(2025)</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>